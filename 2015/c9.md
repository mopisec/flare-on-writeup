# C9 - FLARE-ON Challenge 2015

IDAで静的解析し、`0x401091` 周辺のコードを見てみると、命令と命令の間に処理に関係のないデータが挿入されており、正常に逆アセンブルできていないことがわかります。

Immunity Debugger等のデバッガーでプログラムをデバッグしていくと、Flagと入力は一文字ずつ `0x401B1A` の命令で（ROL, XORなどされた上で）比較されていることがわかります。
また、スタック上に何らかのデータが展開されており、これが入力をXORする際のキーとして用いられていることがわかります。

処理を追いながら、以下のような処理を逆演算するスクリプトを作成し、実行しました。

Solver:

```py
# BPを使いながら集めた0x401B1A時点でのAH,CL,BLレジスタの値
a = [[0x46, 0x56, 0xc3],
     [0x15, 0xf5, 0xcc],
     [0xf4, 0xac, 0xba],
     [0xbd, 0x1b, 0x4e],
     [0xff, 0xb5, 0xf2],
     [0x4c, 0x93, 0xeb],
     [0xef, 0x7e, 0x27],
     [0x46, 0xb8, 0x19],
     [0xeb, 0x23, 0xc6],
     [0xe6, 0xda, 0x42],
     [0xb2, 0x0a, 0x06],
     [0xeb, 0xf2, 0x16],
     [0xf1, 0x01, 0x5d],
     [0xc4, 0x61, 0x53],
     [0x34, 0x5c, 0x55],
     [0x67, 0xc8, 0x0e],
     [0x39, 0x4c, 0x66],
     [0xb5, 0xd6, 0xf4],
     [0x8e, 0x16, 0xf9],
     [0xef, 0x55, 0x30],
     [0x40, 0x67, 0x9a],
     [0x1b, 0xb8, 0x77],
     [0x74, 0xc1, 0x56],
     [0x0d, 0xf8, 0x6b],
     [0x60, 0xbc, 0xf0],
     [0x26, 0x11, 0x8e],
     [0x45, 0xfa, 0xdc],
     [0xa8, 0x9b, 0x2e],
     [0x4a, 0x6b, 0x50]]

# from https://gist.github.com/trietptm/5cd60ed6add5adad6a34098ce255949a
ror = lambda val, r_bits, max_bits: \
    ((val & (2**max_bits-1)) >> r_bits%max_bits) | \
    (val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))

flag = ''

for c in a:
    flag += chr(ror(c[2], c[1], 8) ^ c[0])

print(flag)
```

Output:

```
Is_th1s_3v3n_mai_finul_foarm@flare-on.com
```
